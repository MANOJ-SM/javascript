
// window is the global object that will be present in the browser 

everytime u r running a file along with the execution context , "this" keyword is also created

this ponits to global object // incase of browser it is window 

the value of `this` inside the function is   / global object in node js  and  / window object in browser. 

--------------------------------------
the value of `this` keyword inside function is a global object but incase of 
"use strict" it is undefined 


"use strict"

function abc(){
    console.log("abc");
    console.log(this);  // global object 
}

abc();                                // abc , undefined 
window.abc();                       // in browser -> window obj is shown 


but when you call the function with any keyword like -> window.this -> then again this value points to global object and logs window object in console 

-------------------------------------

// this inside a object 

const obj = {
   x: 10,
   y : function(){
      console.log(this);
   }
}

obj.y();           // y() is called using obj  -- value of `this` here is whole object (get printed)


the function written inside a obj is also  called method 

-----------------------------------------------------------------

// Function Sharing b/w 1 / 2 objects using call() method 

call method is ude when we to make `this` value points to particular object we want 

apply() is also same but diiff in syntax while calling 

bind() is also same but it returns a value of a called function, which can be stored and log leter 

const user = {
   fname : "manoj",
   lname :"medleri",
   printFullname : function (){
         console.log(`my name is ${this.fname} ${this.lname}`);
   }
}

user.printFullname();       

// printfullname  methode is called using user obj hence the this inside method will point to obj 
                    

const user = {
   fname : "manoj",
   lname :"medleri",
   printFullname : function (){
         console.log(`my name is ${this.fname} ${this.lname}`);
   }
}

user.printFullname();       


const user2 = {
    fname : "abhi",
    lname : "alvndi",
}                               


user.printFullname.call(user2);


// there is no printFullname methode in this obj but we can still access it from other object using call by passing object name inside it,   

by this this will point to user2 object and perform printFullname function


// Function Sharing b/w many objects 



const user = {
   fname : "manoj",
   lname :"medleri",
   
}

let printFullname = function (color,hobby){
   console.log(`my name is ${this.fname} ${this.lname} & my favcolor is ${color} & hobby is ${hobby}`);
}

printFullname.call(user,"orange","learning");       // 1st parameter is object for which `this` will be pointing 
                                                   // rest parameters are parameters which wewant to pass inside function 

// printfullname  methode is called using user obj hence the this inside method will point to obj 
                    
const user2 = {
   fname : "abhi",
   lname : "alvndi",
}                               



printFullname.call(user2,"red","ytube");     



// call() and apply() method are same 

diff is -> passing rest parameters inside list using [ ]

 printFullname.apply(user2, ["red","ytube"]);     

// call() and apply() and bind() method are same 

diff is -> bind returns the value of a function which need to stored in variable which will act linke function , which we can call any time 


// call 

printFullname.call(user2,"red","ytube");     

// apply

 printFullname.apply(user2, ["red","ytube"]);     

// bind

const printName =printFullname.bind(user,"blue","movies")
printName();

-----------------------------------

// prcts qtn :


Write a JavaScript function createGreeting that:

Takes two parameters: firstName (string) and lastName (string).
Defines an object person with properties firstName and lastName.
Defines a function greet within createGreeting that logs a greeting message using this.firstName and this.lastName.
Uses call, apply, and bind to invoke the greet function with different contexts:
callGreet: Uses call to invoke greet with the person object as context.
applyGreet: Uses apply to invoke greet with the person object and an array of arguments.
bindGreet: Uses bind to create a bound function bindGreet that can be invoked later with the person object.


function createGreeting(fname, lname) {
    // Define person object with firstName and lastName properties
    const person = {
        fname : fname,
        lname : lname,
    }
    // Define greet function within createGreeting
    greet = function(){
        console.log(`${this.fname} ${this.lname} `)
    }
    
    // Use call to invoke greet with person context (callGreet)
    greet.call(person,fname,lname);
    
    // Use apply to invoke greet with person context and array of arguments (applyGreet)
    
    greet.apply(person,[fname,lname]);
    
    // Use bind to create a bound function and assign it to bindGreet
    
    const userName = greet.bind(person,fname,lname)
    
   
    userName();
}

createGreeting("John", "Doe");


// value of `this` in arrow function 

const obj = {
    x :10,
    y : () => {
        console.log(this)               
    }
}

// `this` is pointing to obj which is at global scope and prints the same ( where the obj has been defined )

// in node - > obj will print // in browser -> window will be print 

// another example 

const obj = {
   x :10,
   z : function (){
      const  y = () => {           // interview qtns : on this keyword value in different situation 
       console.log(this);         // value of `this` here is obj ,  here it prints whole obj 
   }  
   y();

   }
}

obj.z();



// 3.example


function createCounter() {
    // Define counterObj with count property
    const counterObj = {
        count : 0
    };

    // Define increment arrow function within createCounter
    
    counterObj.increment = function()  {
        counterObj.count +=1;
        console.log(this.count);
    };
    
    // Return the increment function
    return counterObj;
    
}
   const counter = createCounter();
   counter.increment(); 1
   counter.increment(); 2


