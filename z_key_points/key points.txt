
1.template litreal : template litreal is a string created using back tick which helps in string interpolation and multi-line strings.

to use javascript variables logic inside strings we use template litreal 

2.string interpolation is when we substute the placeholders or  embeded expressions in the string  
using  dollor and a expression within a curly braces  -->   ${expression} */

str.trim() - removes the white spaces [ spaces infront of str  and at the end of str]

3.what is window object ? 

an window object is browsers object and it is automatically created by the browser
it is basically a global object with lots of properties and methodes 
  --- used to interact with the browser and the document object model (DOM)

4.  <!-- script.js  are not included at head bcoz DOM elements will not load before body -->

5.web browser converts html document into tree like struture to render the information , this tree like struture is called DOM 


// 1. selecting ID        {      document.getElementById(" IDName ")                  }
// 2. selecting class     {      document.getElementesByClassName("class name")       }
// 3. selecting tag       {      document.getElementByTagName("tag name")             }
// 4. query selector      {      document.querySelector("ID,Class,Tag name")          } 

let manoj = document.querySelector("p");
manoj.innerHTML = "lorem";                                            nner texrt changed 

let student11 = document.getElementById("img1").src = "bird.jpeg";    attribute value changed  

    const para = document.createElement("p");                    new ele creation 
    para.innerHTML = "manu i am doing well";

    const parent = document.getElementById("parent");        appending it in div(some parent) - last child 
    parent.appendChild(para);

    const exisitingPara = document.getElementById("oldpara");         making it as 1st child of parent 
    parent.insertBefore(para,exisitingPara);  

    exisitingPara.remove();


###     document.getElementById("box").onmouseover = changeText;         dom event 

        function changeText(){
            document.getElementById("box").innerHTML = "square";
        }

DOM event listner --

1.as many tasks can be performed on same ele with same eventListener
2.as many as  different events can be attached to same ele 
3.example for setting and removing event listner

document.querySelector("button").addEventListener("click",textChange);

        function textChange(){
            document.querySelector("p").innerHTML ="manu";
        }

        document.querySelector("button").addEventListener("dblclick",function (){
            document.querySelector("button").removeEventListener("click",textChange);

        });


events - onclick , onmouseover,onmouseout

// some EventListners 

// mouse - click,dblclick,mouseover



-----------
event bubbling - inner event is handled first and then outer event is handled 
event capturing - outer event is handled first and then inner event is handleds

event bubbling ( default - false - no need to write explicittly)

            document.querySelector("button").addEventListener("dblclick",function (){
            document.querySelector("button").removeEventListener("click",textChange);

            },false);

event capturing   ( use capture parameter need to be wriiten as true )          

            document.querySelector("button").addEventListener("dblclick",function (){
            document.querySelector("button").removeEventListener("click",textChange);

            },true);

            -- outer event is handled first and then later inner event will take place 


----------------------------------------------

ES6 - ecmaScript 2015 // in 2015 a major revison done to javascript where the lot of new features were introduced .  
// all the features introuced in ES6 are known as ES6 features 

Let and const
Arrow functions
Template literals
Default parameters
Promises
Modules
Classes
Destructuring

--------------------

// higher order function : function which takes another function as parameter 
// call back function : function which is passed as parameter 


all methodes are immtable - orginal array dosent get affected 

1.map() - is h o f which transform the each array ele acc the given function and returns the new array 

## mapping each array ele with a function - arr.map(square); , arr -> array , square -> function 


const arr = [ 2,3,4,5,6,7,9];

function square(x){
    return x * x
}

const squaredArray = arr.map(square);
console.log(squaredArray);

const sq = arr.map( x => { return x * x} );

2. filter() - travser through array or object and filter out the ele which meets the function condition and return the new array of ele which meets the condition

example:

const marks = [ 23,34,45,56,34,39,67,56,68,];

const goodMarks = marks.filter(mark => mark > 50);
console.log(goodMarks);


3. reduce() - is a hof which takes the array and return the single value by applying the function

example :

const marks = [ 1,2,3,4];

const sum = marks.reduce( (acc,cur) => {
    acc = acc + cur;
    return acc;
},0);
console.log(sum);


all together


const arr = [1,2,3,4,5,6];

const new_array = arr.filter( ele =>  {
    return ele % 2 == 0;                    // 2,4,6
}).map( ele => {
    return ele * ele;                       // 4,16,36
}).reduce( (acc,ele) => {
    acc = acc + ele;                        // 56
    return acc;                              
},0)

console.log(new_array);

----

function sumOfSquarednumbers(numbers){
    return numbers
    .filter( ele => ele % 2 == 0)
    .map(ele => ele*ele)
    .reduce( (acc,ele) => acc + ele)

}

const numbers = [1,2,3,4,5,6];
console.log(sumOfSquarednumbers(numbers));

-----------------------------------------------------------------------------

Global excution context - a G E C consist of two phases for executing the js code 1.memory allocation another is 2.code execution where in memory for all the variables and function is allocated first then afer the code is executed line by line  

and for function another local execution context will be created .


call stack : a datastruture that keeps track of function calls 

hoisting - we can access a variable orn function before declare them . ( bcoz of excution context )

variable hosting  - we can access the variable before we declare it 

var a =10;
console.log(a);


function hoisting - we can access the variable before we declare it 


greeting();

function greeting(){
    console.log("dsAF");                 / o/p -> dsAF
}


arrow function / first expression :

const greeting = () => {
  console.log("hello");                / o/p -> undefined 
}

------------------------

anonymous function : function without their own identity  are termed as anonymous function

ex: arrow functions :
let a = () => {
    console.log("3");
}
-------------------------

// Named Function Expression 

let a = function manu() {
    console.log("3");
}

a();        // 3

manu();  //referenceError : manu is not defined ;

----------------

// self calling or immediately calling functions   // practice 

(function person(){
    console.log("manu");
}) ();


-----------------------------------

lexical env : a mmry which points to its parent mmry is called as lex env  , and this is how we can access the parent scope from child scop

every mmry phase in execution context will have its own  lexical env poiniting to its parent mmry

lex of gobal execution context is null 

scope chain : checking for a variable in lexical_env of parent until its not found , if not found it returns null

closure : a function along with its lexical_env is called closure .

temporal dead zone: the variable declred using let and const will be allocated with mmry but cant be accessed until the value is initailaized  is called   "let and const temporal dead zone" 

-------------------

data struture : 

A data structure is a way of organizing and storing data in a computer so that it can be accessed and modified efficiently.  

oop : representing the essential features of the object 

array : can stores the multiple values in one variable of differnt data type , and is mutable 

string : stores sequence of char  in dbl quts 


-------------------

Attributes:
Attributes provide additional information about an HTML element

Tags:
Tags are the keywords enclosed within angle brackets (e.g., <p>, <h1>, <img>, <div>).


--------------------------
prototype:
every js object has  some special property  attached with it called prototype

## helpul if we dont have prpty inside the object but we can still have special prptoies which are present inside prototype

const user = {
   name : "manu",                                           // properties 
   city : "sgn",
   printDetails : function(){                                   // method 
       console.log(`i am ${this.name} from ${this.city}`);     
   }
};

array also prototype attached with it 

to get the prototype of any object we use

object.__proto__

prototype of object.prototype (last node) is null 

object.__proto__.__proto__

prototype chain - js tries to find the property in the object itself first then in its prototype then in its prototype's prototype and so on


----------------------
synchronous prmigng - prgming in which code is executed line by line code sequentialy.

js is synchronous language but in case of any use of callback , promises or event loops it will behave as asynchronous ;

asynchronous progming : Asynchronous programming is a programming that allows tasks to run concurrently without waiting for other tasks to complete 

some asynchronous tasks 
 
1.callback
2.promises
3.async/await


----------------
asynchronous functions :

setTimeout  : is a function that allows you to delay the execution of a particular piece of code by a specified amount of time.

setTimeout( () => {    
    console.log("hello world!");        
},3000);

-------------------

// normal callback function  : 


function createMessage(name, callback) {
    const message = `hello ${name}`;
    callback(message);                      // invokes the callback function  with the created message
}

function displayMessage(message) {
    console.log(message);
}

// Pass `displayMessage` as a callback to `createMessage`

createMessage('manu', displayMessage);

### why callback function is used ?

// when i want to call  a function only after my previous  function has completed its execution . then i will use 
callback  function .

with setTimeout ---

function createMessage(name,callback){            // here callback ==  dispayMessage()

    setTimeout(() => {
        const message = `hello ${name}`;
        callback(message);
    },3000);

}


---------------------