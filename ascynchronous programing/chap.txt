

in regualr prming only one piece of code is executed at a time 

js is single threaded synchronous language :

--> it executes one line of code at a time and one by one line 

console.log("hi");
console.log("hello");
comsole.log("bye");


---------------
asynchronous progming : Asynchronous programming is a programming that allows tasks to run concurrently without waiting for other tasks to complete 


 asynchronous functions : setTimeout , featch ...
---------------------------------------------------


setTimeout (webAPI) provided by browser:
------------

setTimeout is the webAPi which allows to execute some pieceof code after some delay 

1000ms = 1 sec 

setTimeout( "() => {             " inside the doublee qts " whatever is there , it is call back function 
                                                    bcoz it is passed inside another( setTimeout) function 
}",1000);


ex:
------
console.log("manu");

setTimeout( () => {    
    console.log("hello world!");        
},1000);

console.log("manoj");
console.log("manoj");
console.log("manoj");
console.log("manoj");
console.log("manoj");
console.log("manoj");

output:
-------
manu
manoj
manoj
manoj
manoj
manoj
manoj
hello world!

---------------
Note :

1. in case of multiple setTimeout the least time (delay) will executed one after the other 1000 is executed first and 2000 will execute second after 1000 is completed 

2. in case of same time dealy the one which is written first will be excuted first 

-----------------------------------
Event Loop : 

what happened in the above code is when it sees the callback function with some dely it dosent wait for that and excute it , it just skips it and runs rest of code and later come back to this call back function and execute this 

when event loop sees call back function  with dealy ,the same code will be pushed to the browers  with webApi setTimeout which will have timer in it  executes it and pushes it to the call back queue , and then, when  all the rest of code is executed (empty call stack ) , this code in  "call back queue" is pushed  to call stack , and then it executes with its delay 
---------------------------------------------
Note :
js is synchronous or asynchronous language ?

js is synchronous language but in case of any use of callback , promises or event loops it will behave as asynchronous ;


---------------------------

call back queue : when event loop sees call back function  with dealy ,the same code will be pushed to the browers  with webApi setTimeout which will have timer in it  executes it and pushes it to the call back queue , and then, when  all the rest of code is executed (empty call stack ) , this code in  "call back queue" is pushed to call stack  , and then it executes with its delay .


Micro Task queue (API calls and promises goes inside M T queue):
--------------------

similar to call back queue diiff is ,

when we use the featch API which is also time taking , js will push that featch function to browser and after some time of its dealy its executed and pusshed to micro task queue

this micro Task queue has higher prioprity then call back queue 

so event loops goes or picks code in the M T queue and put in the call stack for execution 


// imp interview qtn 

1. what is event loop or  how it works 
2.what is call back queue or Micro Task queue
3.which items goes into the c b queue or which items goes into the M T queue 
4. set of code line with setTimout and  fetch like functions and ask the output order ( M T queue > C B queue )


// callback :

a function which is passed as an argument to another function 


// normal callback function  : 

function createMessage(name){
    const message = `hello ${name}`
    return message;
}


function dispayMessage(message){
    console.log(message);
}

const message = createMessage('manu');
dispayMessage(message);


// result will be seen immediately - hello manu 
-----------------------------------

// here with some time delay , it will not execute properly 

function createMessage(name){
    setTimeout(() => {
        const message = `hello ${name}`;
        return message;
    },3000);
}


function dispayMessage(message){
    console.log(message);
}

const message = createMessage('manu');
dispayMessage(message);


// o/p -> undefined  /  as callback function is taking time to execute but js dosent wait for anything as it is synchronous

----------------------------------- 

// to executee call back function in case of  time taking functions using callback keyword :

function createMessage(name,callback){            // here callback ==  dispayMessage()

    setTimeout(() => {
        const message = `hello ${name}`;
        callback(message);
    },3000);

}

function displayMessage(message){
    console.log(message);
}

createMessage("manu",displayMessage);      // hello manu / after 3 seconds 


// here in the above the callback is representing  the dispayMessage function. *********

// this is used when  we want to call a function after a certain time period but want to it to execute after some dealy .


//when we use setTimeout like function inside another function , then the outer function will became  asynchronous .

// multiple task start to happen simultenously 

// i want to call  a function only after my previous  function has completed its execution . then i will use 
callback  function .

//  callback function is used to call a function after a certain time period .

---------------------------------------------------


// callback hell problem with no time delay 

function first(val){
    return val +1;
}

function second(val){
    return val +2;
}

function third(val){
    return val +3;
}

function doOperation(){
    let result = 0;
    result = first(result);
    result = second(result);
    result = third(result);
    console.log(`result ${result}`);
}

doOperation();


// with time delay 


NOTE : here in this case of syncronyous programming , the output will be NAN as the main function is skipped as it takes time to execute and in syncronyous programming js wont wait for anything 

function first(val){
    setTimeout( () =>{
        return val +1;
    },1000);
    
}


function second(val){
    return val +2;
}


function third(val){
    return val +3;
}


function doOperation(){
    let result = 0;
    result = first(result);
    result =  second(result);
    result  = third(result);
    console.log(result);


}


doOperation();  

// NAN is o/p  -> because first function is taking time to execute and second and third function are executing before first function is done .


-----------------------------------


// with time delay using callback  function 


NOTE : by callback function js starts behaving like asynchronous  programming  , it waits for the first function to complete and then executes the callback  function and so on .

if i have to execute one function only after execution of its previous function  then i have to use callback function . 



function first(val,callback){          // first fun is called with one intial value and one callback fun
    setTimeout( () =>{
        const result =  val +1;
        callback(result);        // here result  is passed  to same callback function in which second fun is called 

    },1000);
    
}


function second(val,callback){     // here result is 1st parameter and callback is call function 
    const result1 =  val +2;
    callback(result1);             // result1 is passed to callback function 
}


function third(val,callback){    //  third fun is called result1 and a call function.
    const result2 =  val +3;
    callback(result2);           //  result2 is passed to callback function

}


// this below struture is called pyramid of Doom , bocz of its appernce and using multiple callback within

function doOperation(){
    let result = 0;
    result = first(0, (result) => {
        second(result, (result1) =>{
            third(result1, (result2) => {           // third fun is called result1 and a call function.and what 
                console.log(`result ${result2}`);    this call back fun is doing is , it is printing final result
            })
        })
    })

}


doOperation();           // result 6 


// with the help of callback fun we are making sure that , that my callback is executed only after my main function is executed eventhougth  it is taking time to execute. 



------------------------------------------------------------------------

harry's view 
------------ 

synchronous - next code will be  blocked until prvs code execute.
asynchronous - next code  will be executed even if previous code is still executing. 

setTimeout - Asynchronous;


asynchronous prming - multiple tasks(requests) or infinate no of taskss , can be done at a time .

there are 3 ways of writing asynchronous code 

1.callback
2.promises
3.async/await

----------------------

promise - is the promise of code execution in future .

it is the object and  connection blw , producing code and conuming code 


three states of promise 
1.pending
2.fulfilled
3.rejected


-------------------------------------------------------------------

// producing code 

const promise = new Promise(function(resolve,reject){

    let promiseResult;

    setTimeout(()=>{
        promiseResult = true;
        if(promiseResult){
            resolve("successfull");      
        }
        else{
            reject("unsuccessfull");
        }
    },3000);

   
});

// consuming code 

promise.then( result => console.log(result));
promise.catch( err => console.log(err));



// if code reult will be resolved then , promise.then will be called 
// if code result will be rejected then , promise.catch will be called

// the resolve value will passed as an argument  to the callback function of promise.then ("successfull")
// the reject value will passed as an argument to the callback function of promise.catch  ("unsuccessfull")



/*

1) above arrow function in normal function 

promise.then(function(result) {
    console.log(result);
});


2) once the code of promise is ecxecuted it will be in pending stage at first and then move to resolve or reject phase result.



*/

------------------------------

practice problem 



function simplePromiseDemo(success) {
    // Return a Promise
    return new Promise((Resolve,reject) => {

    // Log "Promise is pending..."
    
    console.log("Promise is pending...");

    // Simulate a network request with setTimeout
    setTimeout( () => {
            if(success){
                Resolve("Promise fulfilled: Data received!");
            }
            else{
                reject("Promise rejected: Error occurred!");
            }
        },2000);
        
    });


}
    
    

// Demonstrate fulfilled state
simplePromiseDemo(true).then( result => console.log(result));

// Demonstrate rejected state
simplePromiseDemo(false).catch( err => console.log(err));


-----------------------------------------------------------------------------------------------------

fetch API :

this is basically provided by browser to make http request to server to get some data from server  


fetch() methode is used to make an api call (rqst)  to server to get some data from server 

(insted of typing url in browser search bar we can use this )

whenver i fetching a url it returns me the promise object , it needs to be stored in varibale and consoled 

** intial state of promise ois pending **


/// promise is either fullfilled or rejected / resolved or rejected 

as promise is Asynchronous , it takes time to get the data from server so it is pending state and then it is resolved or rejected 

in the mean time , it excutes other code block that comes after promise code and once finsed all code snippetes it returns to promise code which will be either  resolved or rejected 

----------------------------------------

// fetch problem example 

let promiseObject = fetch("https://dummyjson.com/products/1");

console.log(promiseObject);

promiseObject.then( response => response.json().then( result => console.log(result)));

// promiseObject.catch( ERRresponse => console.log(ERRresponse));

// we can use .json() methode to convert data into json formate data 



---------------------------------------------------------------------------------------------

practice problem promise 

function fetchData(success) {
    // Return a Promise
    
    return promise = new Promise((resolve,reject) => {
    
    // Simulate a network request with setTimeout
    
    setTimeout(() => {
        if(success){
            resolve("success");
        }
        else{
            reject("failure");
        }
        
    },2000);
  });
    

}

function processData(success) {
    // Call fetchData
    fetchData(success)
    .then( response =>  { console.log(response);
        
    })
     .catch( err => { console.log(err);
     });
    // Handle the failure case with .catch()
   

}

// Simulate a successful request
processData(true);

// Simulate a failed request
// processData(false);